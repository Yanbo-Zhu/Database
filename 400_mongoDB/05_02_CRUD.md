
https://juejin.cn/post/7073273393528700964#heading-30
https://juejin.cn/post/7272730422735929396#heading-29


# 1 增删改查 


> 首先声明：**`MongoDB`中的多数操作都带有隐式创建特性**，啥意思呢？好比你使用一个数据库，如果没有则会自动创建；使用一个集合时，没有也会自动创建……


## 1.1 Beispiel1

这里咱们先创建一个数据库和集合，如下：



1 Insert

这里咱们先创建一个数据库和集合，如下：

```JavaScript
// 切换到zhuzi库，没有会自动创建
use zhuzi;
// 向xiong_mao集合插入一条数据（没有集合会自动创建）
db.xiong_mao.insert({_id:1});
```

和`Python`一样，最后的分号可写可不写，不过建议写上，以此增加代码的可读性。

现在继续往`xiong_mao`集合中插入两条数据：

```JavaScript
db.xiong_mao.insert({_id:2, name:"肥肥", age:3, hobby:"竹子"});
db.xiong_mao.insert({name:"花花", color:"黑白色"});
```

---

2  查询 

```js
// 查询xiong_mao集合的所有数据
db.xiong_mao.find();

// ------- 返回结果 ----------
[
  { _id: 1 },
  { _id: 2, name: '肥肥', age: 3, hobby: '竹子' },
  {
    _id: ObjectId("64d0b843fa3b00006f0044d6"),
    name: '花花',
    color: '黑白色'
  }
]

```



注意观察第三条数据，在插入时我们并未指定`_id`值，可为啥还是有这个字段呢？因为`_id`是`mongoDB`的默认字段，每个文档（每行数据）必须要有该字段，如果插入时未指定该字段，会自动生成一个类似于雪花`ID`的`ObjectId`值，`mongoDB`会使用`_id`来维护数据的存储结构（类似于[`InnoDB的隐藏列-row_id`](https://juejin.cn/post/7155359629050904584#heading-11 "https://juejin.cn/post/7155359629050904584#heading-11")，后面再细聊）。


如何根据指定条件查询数据呢？如下：

```JavaScript
// 查询_id=2的数据
db.xiong_mao.find({_id:2});
// 查询name=花花的数据
db.xiong_mao.find({name:"花花"});
```

大家会发现，前面我们以`Json`形式将数据插入到集合后，在查询时，咱们可以直接通过`Json`中的字段名来操作，这也就印证了最开始所说的“半结构化”特征，因为像`Redis、Memcached`这类`NoSQL`，虽然也能把数据`Json`序列化后存进去，但想要操作时，只能先读出来再反序列化成对象，不能直接对序列化后的`Json`字符串进行操作！

---


3  修改 删除 

最后再来学习一下修改、删除操作：

```JavaScript
// 将_id=2的数据，爱好修改为：吃竹子、睡觉
db.xiong_mao.update({_id:2},{hobby:"吃竹子、睡觉"});
// 上面那种方式，会导致其他字段变null，要记得加{$set:}，表示局部修改
db.xiong_mao.update({_id:2},{$set:{hobby:"吃竹子、睡觉"}});

// 删除_id=1的数据
db.xiong_mao.remove({_id:1});
```

OK，我们过了一下最简单的`CRUD`操作，这里主要是让大家先熟悉下语法，诸位也可以自行多练习一下。

相较于`SQL`的语法来说，`MongoDB`的语法显得有点反人类；反观同为`NoSQL`的`Redis`，它的命令则显得简洁清爽许多。当然，熟悉`JS`的小伙伴，接触这个语法不算太难，毕竟这就是`JS`的语法，如果只是纯后端的开发者，想适应过来需要一定的练习。






## 1.2 Beispiel 2 

für Schreiboperationen
![](images/Pasted%20image%2020250206221421.png)


Beispiel für Leseoperationen
// 在某个 collection 查找某个 ducument 
db.users.find()  
db.message.find() 

![](images/Pasted%20image%2020250206221436.png)

![](images/Pasted%20image%2020250206221443.png)



# 2 Einfügen:  `insert`

```js
db.posts.insert({
  "title": "Second Post",
  "user": "Alice"
})


db.posts.update({
  "user": "Alice"
}, {
  "title": "Second Post", 
  "user": "Alice"});
}, {
  upsert: true
})


db.posts.save({
// 如果不写 "_id": Object("45c230a123d45efab2340"),, 自动生成一个 id 
  "title": "Second Post",
  "user": "Alice"
})


db.posts.save({
  "_id": Object("45c230a123d45efab2340"),
  "title": "Second Post",
  "user": "Alice"
})

```

- `**insert(document)**`: häufigste Methode zum Einfügen neuer Dokumente in eine Kollektion
- `**document**` als einziges Argument der Methode
- `**_id**` wird automatisch generiert und dem Dokument zugewiesen
- Verursacht ggfs. das Anlegen einer neuen Kollektion, wenn die angegebene nicht existiert
- `**update(selectionCriteria, updateStatement, options)**`: alternative Methode zum Einfügen von Dokumenten
- `**upsert**` ist `**true**` wenn ein neues Dokument angelegt werden soll wenn kein Dokument mit den Suchkriterien in der Kollektion vorhanden ist
- `**save(document)**`: weitere Alternative, die optional die Definition einer eigenen `**_id**` erlaubt

## 2.1 insert 


`MongoDB`中提供了三个显式向集合插入数据的方法：

```JavaScript
// 向集合插入单条或多条数据（需要用[]来包裹多个文档）
db.xiong_mao.insert([
    {_id:4, name:"黑熊", age:3, food:{name:"黄金竹", grade:"S"}},
    {_id:5, name:"白熊", age:4, food:{name:"翠绿竹", grade:"B"}}
]);

// 向集合插入单条数据
db.xiong_mao.insertOne({_id:6, name:"棕熊"});

// 向集合批量插入多条数据
db.xiong_mao.insertMany([
    {_id:7, name:"红熊", age:2, food:{name:"白玉竹", grade:"S"}},
    {_id:8, name:"粉熊", age:6, food:{name:"翡翠竹", grade:"A"}}
]);
```


从案例中可发现，每个字段可以无限嵌套`json`。同时，这三个`insert`方法都有两个可选项，如下：

```JavaScript
db.collection.insertXXX(
   [ <document 1> , <document 2>, ... ],
   {
      writeConcern: <document>,
      ordered: <boolean>
   }
)
```

`writeConcern`表示嵌套文档，这个咱们后续再细说；`ordered`表示本次是否按顺序插入，`2.6`以上版本默认为`true`，表示按指定的顺序插入数据。


## 2.2 `bulkWrite()`

除开上面三个常用的插入方法外，`MongoDB`还可以通过其他方式实现数据新增，如：

```JavaScript
const bulkOps = [
  {insertOne: {document: {_id: 9, name: "黄熊"}}},
  {insertOne: {document: {_id: 10, name: "灰熊"}}}
];
db.xiong_mao.bulkWrite(bulkOps);
```

`bulkWrite()`方法可以传入一个操作数组，`MongoDB`会按照给定的操作顺序依次执行，其中还可以放修改、删除等`MongoDB`支持的操作。最后，还能通过修改命令，向集合中隐式插入数据，在使用修改命令时，将`upsert`设为`true`即可（后面会演示）。



# 3 Löschen: 

## 3.1 `remove`

```js

// 根据指定条件删除集合中的数据
db.xiong_mao.remove({_id:1});

// 删除集合中的所有数据（不写条件即可）
db.xiong_mao.remove({});

db.collectionName.remove(
	<query>, // 条件；
	{				
    	// 是否仅删除一条数据； 如果 justOne 不选择或者参数为 false 则表示删除匹配到的所有文档；
    	// > **如果remove不带有条件的话（但仍要在条件处带有 `{}`表示空条件），就是删除所有**;	
		justOne: <boolean>, 
        
        // 如果抛出意外，抛出的异常级别；
        writeConcern: <Document> 
	}
);

db.posts.remove()
//Entfernt alle Dokumente der Kollektion


db.posts.remove({"user": "Alice"})
//Entfernt alle Dokumente mit user=Alice

db.posts.remove({"user": "Alice"}, true)
```


- `**remove(selectionCriteria, justOne)**`: Methode zum Löschen von Kollektionen oder einer oder mehrerer Dokumente
- `**selectionCriteria**`: s.o.
- `**justOne**`: zeigt an, dass bei mehreren Dokumenten, die `**selectionCriteria**` erfüllen, nur eines gelöscht wird


`MongoDB`中的删除命令，有`remove、delete`两类方法：




## 3.2 delete

```js



// 根据条件删除单条数据（有多条数据满足条件时，只会删第一条）
db.xiong_mao.deleteOne({_id:6, name:"棕熊"});

// 根据条件删除多条数据（满足条件的全部删除）
db.xiong_mao.deleteMany({name:"红熊"});


// 根据条件删除满足条件的第一条数据，并返回删除后的数据
db.xiong_mao.findOneAndDelete({_id:2});
```


当然，这里只列出了根据等值条件删除的操作，类似于`SQL`中的`<、>、in、or、and……`怎么写呢？这些放到后续的查询操作中讲解，因为条件过滤器在`MongoDB`中是通用的。

# 4 Aktualisieren 


## 4.1 update

```js
db.posts.update({
  "user": "Alice"
}, {
  $set: {
    "title": "Second Post", 
}}, {
  multi: true
})

//Entfernt ein Dokument mit user=Alice


db.collectionName.update(
	<query>,
	<update>,
	{
		upsert: <boolean>,
		mulit: <boolean>,
		wirteConcern: <Document>
	}
);

--- 这个更新是将符合条件的全部更新成后面的文档，相当于先删除再更新；
> db.collectionName.update({"name": "UrbaneH"}, {"name": "11", "bir": new date()})


--- 保留原来的数据更新，但只更新符合条件的第一条数据；
> db.collectionName.update({"name": "UrbaneH"}, {$set: {"name": "xiaohua"}})

--- 保留原来的数据更新，更新符合条件的所有数据；
> db.collectionName.update({"name": "UrbaneH"}, {$ser: {"name": "xiaohua"}}, {mulit: true})


--- 保留原来的数据更新，更新符合条件的所有数据，没有符合条件时插入数据；
> db.collectionName.update(
	{"name": "UrbaneH"},
	{$set: {"name": "xiaohua"}},
	{
		mulit: true,
		upset: true
	}
)


```

- `**update(selectionCriteria, updateStatement, options)**`: Methode zum Aktualisieren von Dokumenten einer Kollektion (oder zum Einfügen eines neuen Dokuments falls `**selectionCriteria**` durch kein existierendes Dokument erfüllt werden)
- `**selectionCriteria**`: enthält einfache oder zusammengesetzte Anfrageselektoren
- `**updateStatement**`: spezifiziert die zu aktualisierenden Felder
- `**options**`: verschiedene Optionen, zum Beispiel ob ein oder mehrere Dokumente aktualisiert werden sollen

> **query**：update的查询条件，类似sql update查询where后面的部分；

> **update**：update的对象和一些更新的操作符（如$, $inc, ......）等，也可以理解为sql update查询内的set后面的部分；

> **upsert**：`可选`，这个参数的意思是，如果不存在update的记录，是否插入objNew，默认为 `false` 不插入；`<boolaen>类型`

> **mulit**：`可选`，这个参数的意思是，是否只更新找到的第一条数据，默认为 `false` ，如果为 **true** 则将所有查询到的数据都进行更新；`<boolean>类型`

> **wirteConcern**：`可选`，抛出的异常级别

  


```JavaScript
// 根据条件修改集合中的单条数据（多条数据满足条件时，只修改第一条）
db.xiong_mao.updateOne({_id:7}, {$set:{name:"英熊"}});

// 根据条件修改集合中的多条数据（color字段不存在时，自动创建并赋值）
db.xiong_mao.updateMany({age:3}, {$set:{color:"黑白色"}});


// 根据条件修改集合中的单条数据（可以通过.分割的形式，修改嵌套的json）
db.xiong_mao.update({_id:8}, {$set:{age:3, "food.grade":"C"}});

// 根据条件修改集合中的单/多条数据（如果想通过update更新多条，需要使用multi）
db.xiong_mao.update({age:3}, {$set:{hobby:"竹子"}},{multi:true});
```

修改操作默认是全量修改，即使用指定的值，覆盖原有的整条数据，如果有些字段值在修改时未给定，则会变为`null`（消失）。为此，如若只想修改某几个字段，记得在前面加上`$set`选项。

当然，这里也仅是用`_id`在做等值条件修改，后面讲完查询操作后，大家可以自行套入各种复杂条件进行修改。

---


还记得提过的“修改时隐式新增”嘛？演示一下：

```JavaScript
db.xiong_mao.update(
	{_id:11}, 
	{name:"紫熊", age:3, food:{name:"明月竹", grade:"A"}}, 
	{upsert:true}
);
```

在修改时，只需指定`upsert:true`即可，这样在未匹配到对应条件的数据时，会将本次修改的数据插入到集合中，而前面演示的所有修改方法，都支持指定`upsert`选项。


## 4.2 `findAndModify()、findOneAndUpdate()、findOneAndReplace()`

修改操作除开上述方法外，还可以通过`findAndModify()、findOneAndUpdate()、findOneAndReplace()`方法来修改，如：

```JavaScript
db.xiong_mao.findAndModify({
  query:{_id:8},
  update:{$set:{color: "紫色"}},
  new: true
});
```

这些`findAnd`开头的修改方法，会根据条件修改满足条件的第一条数据，修改完之后，如果`new`指定为`true`，则会返回修改后的数据，如果为`false`，则返回修改前的数据（其余两个方法类似，不再继续演示）。


## 4.3 replace


// 根据条件替换掉单行数据（使用新数据替换老的数据）
```
db.xiong_mao.replaceOne({_id:6}, {name:"棕熊", age:3, color:"棕色"});
```


# 5 Lesen (READ) 

- `**find(selectionCriteria)**`: Methode zum Finden und Lesen von Dokumenten einer Kollektion
- `**selectionCriteria**` enthält einfache oder zusammengesetzte Anfrageselektoren
- Beachte: alle MongoDB-Operatoren werden mit einem `**$**` eingeleitet

`db.collectionName.find(query, projection);`
-  **query**：`可选` 使用查询操作符指定查询条件；
- **projection**：`可选` 使用投影操作符指定返回的键。查询时返回文档中所有的键值，只需要省略该参数即可。默认为省略；

`db.collectionName.find(query, projection).pretty();`
默认的查询是非结构化的，如果需要使得结果结构化也更加易读，需要在后面加上 pretty()
  

```js
db.posts.find() //alle Dokumente einer Kollektion

db.posts.find({}) //alle Dokumente einer Kollektion

db.posts.find({ "user": "Alice"})

db.posts.find(
  {"user": {$in: ["Alice", "Bob"]}}
) //alle Dokumente mit user=Alice oder Bob

db.posts.find({
  $or: [{"user": "Alice"}, {"user": "Bob"}]}
) // //alle Dokumente mit user=Alice oder Bob

db.posts.find({
  "user": "Alice",
  "commentsCount": {$gt: 10}
}) //alle Dokumente mit user=Alice und commentsCount>10

```


## 5.1 基本查询语句

```JavaScript
// 查询集合所有数据
db.xiong_mao.find();

// 根据单个等值条件查询数据
db.xiong_mao.find({_id:2});

// 查询满足多个等值条件的数据（and查询）
db.xiong_mao.find({age:3, "food.grade":"S"});

// 查询满足任意一个条件的数据（or查询）
db.xiong_mao.find({$or: [{age:2}, {"food.grade":"S"}]});

// 查询单字段满足任意一个条件的数据（in查询）
db.xiong_mao.find({age:{$in: [2, 4]}});

// 查询颜色为黑白色，并且年龄小于5岁的数据
db.xiong_mao.find({color:"黑白色", age:{$lt: 5}});

// 查询爱好为竹子，或id大于9的数据
db.xiong_mao.find({$or: [{hobby:"竹子"}, {_id: {$gt:9}}]});

// 查询id小于等于5，并且（age大于等于2 或 name为肥肥）的数据
db.xiong_mao.find({
	_id:{$lte:5}, 
	$or: [{age: {$gte:2}}, {name:"肥肥"}]
});

// 查询name不为“白熊” 或 age 不大于 2 的数据
db.xiong_mao.find({$nor: [{name:"白熊"}, {age:{$gt:2}}]});

// 查询id在3~5之间的数据（between and范围查询）
db.xiong_mao.find({$and: [{_id:{$gte:3}}, {_id:{$lte:5}}]});

// 查询name以“粉”开头的数据（like右模糊查询）
db.xiong_mao.find({name:/^粉/});
```

上述一些查询语句，对应着`SQL`中的基本查询，如`=、<、>、<=、>=、in、like、and、or`，大家仔细观察会发现，其中有许多`$`开头的东东，这个是啥？在`MongoDB`中称之为操作符，操作符有许多，分别对应着`SQL`中的关键字与特殊字符，下面列写常用的：

|SQL|MongoDB|
|:-:|:-:|
|`=`|`:`|
|`=、<、>、<=、>=、!=`|`$eq、$lt、$gt、$lte、$gte、$ne`|
|`in、not in`|`$in、$nin`|
|`and、or、not、is null`|`$and、$or、$not、$exists`|
|`+、-、*、/、%`|`$add、$subtract、$multiply、$divide、$mod`|
|`group by、order by`|`$group、$sort`|
|`……`|`……`|

上表仅仅只列出了一些在`SQL`中比较常见的，实则`MongoDB`提供了几百个操作符，以此来满足各类场景下的需求，如果你想要详细了解，可以参考[MongoDB官网-Operators](https://link.juejin.cn?target=https%3A%2F%2Fwww.mongodb.com%2Fdocs%2Fv6.0%2Freference%2Foperator%2F "https://www.mongodb.com/docs/v6.0/reference/operator/")，当然，如果你英语阅读能力欠佳，可以参考[MongoDB中文网-运算符](https://link.juejin.cn?target=https%3A%2F%2Fdocs.mongoing.com%2Fcan-kao%2Fyun-suan-fu "https://docs.mongoing.com/can-kao/yun-suan-fu")。


---

接着来看看其他查询的语法：

```JavaScript
// 对指定字段去重，并返回去重后的字段值列表
db.xiong_mao.distinct("age");

// 根据条件统计集合内的数据行数
db.xiong_mao.count({age:3});

// 根据条件进行分页查询（limit写行数，skip写跳过前面多少条）
db.xiong_mao.find({_id:{$lt:6}}).skip(0).limit(2); // 第一页
db.xiong_mao.find({_id:{$lt:6}}).skip(2).limit(2); // 第二页

// 根据指定字段进行排序查询（order by查询）
// 根据年龄升序，年龄相同根据id降序（1：升序，-1：降序）
db.xiong_mao.find().sort({age:1, _id:-1});

// 投影查询：只返回指定的字段（0表示不返回，1代表返回）
db.xiong_mao.find({color:"黑白色"}, {_id:0, name:1, color:1});
```

这里又列出了一些`SQL`中经常执行的操作，如统计、去重、排序、分页、投影查询等，和`SQL`一样，不同类型的函数，执行的优先级不一样，例如：

```JavaScript
db.xiong_mao.find({_id:{$lt:6}}).limit(2).skip(2).sort({_id:-1}).count();
```

这条查询语句中，包含了`limilt()、skip()、sort()、count()`四个方法，可实际的执行顺序，跟书写的顺序无关，这些方法同时存在时，执行的优先级为：`sort() > skip() > limilt() > count()`。

---

1
AND查询
db.collectionName.find({key1:value1, key2: value2});`
**如果相同的字段出现的话会以最后一次出现为准；**
**类似于 where 的 WHERE key1 = value1 AND key2 = value2；**

2
OR查询
类似于 WHERE key1 = value1 OR key2 = value2;
```
db.collectionName.find({
	$or: [
		{key1: value1}, {key2: value2}
	]
}).pretty()

```

3
AND和OR查询
> `db.collectionName.find({"age": {$gt: 50}}, $or: [{"name": "UrbaneH"}, {"name": "MongoDb"}]).pretty();`
> 
> **这就类似于 WHERE age > 50 AND (name = “UrbaneH” OR name = “MongoDB”);**



4
数组中查询
db.collectionName.find({shuzu: "baohanneirong"})
⬆️表示查询shuzu中的数组包含baohanneirong的文档
只需要使用包含数组的字段作为键，要包含的值作为值就可以了;
db.collectionName.find({shuzu: {$size: 3}});
⬆️表示查询shuzu长度为3的数据


5
模糊查询

**在MongoDB中，模糊查询是依靠正则表达式的方式来进行实现的；**
**以斜杠开头以斜杠结尾，不需要使用双引号包裹字符串，例如:**
`db.collectionName.find(name: {/U/})；`
**⬆️表示查询name中包含U字符的文档


 **如果是对于数组的内容进行模糊查询也可以使用上述方法，MongoDB的正则可以直接匹配数组中所有元素；**
**例如一个文档中的shuzu: [“吃饭”， “喝水”，“睡觉”]**
`db.collectionName.find({shuzu: {/吃/}});`
**⬆️也可以匹配到**

7
排序
`db.collectionName.sort({key1: 1, key2: -1});`
**1是升序，-1是降序**

8 
分页
db.collectionName.find().sort({query}).limit(rows).skip(start);	
1⃣️ sort 先根据需要的条件排序；
2⃣️ limit 是讲每页分为多少条数据；
3⃣️ skip 是指当前显示第几页；

9
总条数
db.collectionName.count();
db.collectionName.find({query}).counu();


10
去重
db.collectionName.distinct("字段");
返回值是对应字段的剩余的值（去重后）;


11
返回指定字段
这也是上文中提到的 projection 的内容；
db.collectionName.find({name: "UrbaneH"}, {age: 0});
⬆️表示查询集合中name的值为UrbaneH的数据，但不返回age字段；
⚠️注意:
0和1不可以同时使用；0：不返回；1：返回；
如果使用了0则除了其字段其余都返回，如果使用了1则仅返回其字段





## 5.2 聚合管道查询



好了，如果你想要实现更复杂的查询操作，则可以通过`MongoDB`提供的聚合管道来完成，语法如下：

```JavaScript
db.collection.aggregate(
   pipeline: [ <stage>, <...> ],
   options: {
     explain: <boolean>,
     allowDiskUse: <boolean>,
     cursor: <document>,
     maxTimeMS: <int>,
     bypassDocumentValidation: <boolean>,
     readConcern: <document>,
     collation: <document>,
     hint: <string or document>,
     comment: <any>,
     writeConcern: <document>,
     let: <document> // Added in MongoDB 5.0
   }
);
```

聚合管道方法接收两个入参，第一个是数组型的聚合操作，第二个是可选项，


### 5.2.1 可选项 option 
先解释下常用的选项：

- `explain`：传`true`表示返回聚合管道的详细执行计划；
- `allowDiskUse`：是否允许使用硬盘进行聚合操作，内存不足时使用磁盘临时文件进行计算；
- `maxTimeMS`：指定聚合操作的最大执行时间（单位`ms`），超时会被强制终止；
- `hint`：显式指定使用那些索引进行聚合操作；


### 5.2.2 聚合操作 pipeline 

简单了解几个常用选项后，我们来重点关注一下`pipeline`参数，使用方式如下：

```JavaScript
db.collection.aggregate([
  // 阶段1
  {$stage1: { /* 阶段1的操作 */ }},
  // 阶段2
  {$stage2: { /* 阶段2的操作 */ }},
  // ...
]);
```

观察上述语法，首先咱们需要指定操作符，这是为了声明当前阶段的类型，例如`$group`，接着可以指定每个阶段具体要做的事情。同时，聚合管道中的每个阶段，都会将上一阶段输出的数据，视为当前阶段输入的数据，和`Stream`流类似，下面上些例子理解，如下：

```JavaScript
/* 按年龄进行分组，并统计各组的数量（没有age字段的数据统计到一组） */
db.xiong_mao.aggregate([
    // 1：通过$group基于age分组，通过$sum实现对各组+1的操作
    {$group: {_id:"$age", count: {$sum:1}}},
    // 2：基于前面的_id（原age字段）进行排序，1代表正序
    {$sort: {_id:1}}
]);

/* 按年龄进行分组，并得出每组最大的_id值 */
db.xiong_mao.aggregate([
    // 1：先基于age字段分组，并通过$max得到最大的id，存到max_id字段中
    {$group: {_id:"$age", max_id: {$max:"$_id"}}},
    // 2：按照前面的_id（原age字段）进行排序，-1代表倒序
    {$sort: {_id: -1}}
]);

/* 过滤掉食物为空的数据，并按食物等级分组，返回每组_id最大的熊猫姓名 */
db.xiong_mao.aggregate([
    // 1：通过$match操作符过滤food不存在的数据
    {$match: {food: {$exists:true}}},
    // 2：通过$sort操作符，基于_id字段进行倒排序
    {$sort: {_id: -1}},
    // 3：通过$group基于食物等级分组，并通过$max得到_id最大的数据，
    // 并通过$first拿到分组后第一条数据（_id最大）的name值
    {$group: {_id:"$food.grade", max_id: {$max:"$_id"}, name:{$first: "$name"}}},
    // 4：最后通过$project操作符，只显示_id（原food.grade）、name字段
    {$project: {_id:"$_id", name:1}}
]);
```

上面举了三个简单的聚合操作例子，但相信对于绝大多数刚接触的小伙伴来说，这些语句看起来十分头大，一眼望过去全都是符号+符号，这是因为`MongoDB`中，使用操作符代替了`SQL`中的函数与关键字，所以越是复杂的场景，使用到的操作符越多，对传统型的`SQL Boy`来说，可读性会越差~


### 5.2.3 操作符

这里为了便于大家理解，先列出`MongoDB`聚合管道操作符和`SQL`聚合关键字/函数的对比：

|SQL关键字/函数|MongoDB聚合操作符|
|:-:|:-:|
|`where、having`|`$match`|
|`group by`|`$group`|
|`order by`|`$sort`|
|`select field1、field2…`|`$project`|
|`limit`|`$limit、$skip`|
|`sum()、count()、avg()、max()、min()`|`$sum、$sum:1、$avg、$max、$min`|
|`join`|`$lookup`|

![](image/Pasted%20image%2020250226220058.png)


当然，上面列出的仅是沧海一粟，`MongoDB`的聚合管道中可用的操作符有几百个，不管是`SQL`中有的，还是没有的功能/函数，都能找到对应的操作符代替，具体大家可以参考[MongoDB官网-Aggregation Pipeline Operators](https://link.juejin.cn?target=https%3A%2F%2Fwww.mongodb.com%2Fdocs%2Fv6.0%2Freference%2Foperator%2Faggregation%2F "https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/")，或[MongoDB中文网-聚合管道操作符](https://link.juejin.cn?target=https%3A%2F%2Fdocs.mongoing.com%2Fcan-kao%2Fyun-suan-fu%2Faggregation-pipeline-operators "https://docs.mongoing.com/can-kao/yun-suan-fu/aggregation-pipeline-operators")。









### 5.2.4 案例 


1
计算每个作者编写的文章总数

```js
{
   _id: ObjectId(7df78ad8902c)
   title: 'MongoDB Overview', 
   description: 'MongoDB is no sql database',
   by_user: 'runoob.com',
   url: 'http://www.runoob.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 100
},
{
   _id: ObjectId(7df78ad8902d)
   title: 'NoSQL Overview', 
   description: 'No sql database is very fast',
   by_user: 'runoob.com',
   url: 'http://www.runoob.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 10
},
{
   _id: ObjectId(7df78ad8902e)
   title: 'Neo4j Overview', 
   description: 'Neo4j is no sql database',
   by_user: 'Neo4j',
   url: 'http://www.neo4j.com',
   tags: ['neo4j', 'database', 'NoSQL'],
   likes: 750
},

```

```js
 db.colltectionName.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
{
   "result" : [
      {
         "_id" : "runoob.com",
         "num_tutorial" : 2
      },
      {
         "_id" : "Neo4j",
         "num_tutorial" : 1
      }
   ],
   "ok" : 1
}

```

将集合内的数据进行分组
`$group` 是用来分组的，里面的参数 `__id` 用来声明用原数据的哪个字段作为分组的索引；⬆️🌰就是将 by_user 这个字段进行分组聚合操作，并且这个字段作为了新的集合的索引；

 
选择聚合函数
`num_tutorial` 参数简单理解就是对于分组后的数据，聚合的办法；⬆️🌰就是选择了 `$sum` 来累加，由于原数据中没有有关作者文章数量的信息，且每一条数据都是一条文章的数据，所以这里使用 `$sum: 1` 含义就是每条数据累加 1。如果选择累加原数据的值，则同样的方法就是 `$字段名称`；

  


---


1 
话归正题，咱们来稍微解读一下前面写出的聚合管道查询语句，先拿最简单的第一条来说：

```JavaScript
/* 按年龄进行分组，并统计各组的数量 */
db.xiong_mao.aggregate([
    {$group: {_id:"$age", count: {$sum:1}}},
    {$sort: {_id:1}}
]);
```

在第一阶段中，使用`$group`操作符来完成分组动作，其中`_id`并不是原数据中的`_id`，而是代表想聚合的数据主键，上面的需求想基于年龄分组，所以`_id`设置为`$age`即可。

> 注意：在聚合查询中，也会使用`$`来引用原数据中的字段，案例中的`$age`并不是一个操作符，而是获取原数据的`age`字段，这种方式也可以用来拿其他字段，如`$name、$color……`。

在第一阶段中，咱们还定义了一个`count`字段，这相当于`SQL`中的别名，该字段的值，则是由`{$sum:1}`统计得出的，这段逻辑相当于：

```java
Map<Integer, Integer> groupMap = new HashMap<>();
for (XiongMao xm : xiongMaoList) {
    Integer age = xm.getAge();
    if (groupMap.get(age) == null) {
        groupMap.put(age, 1);
    } else {
        Integer count = groupMap.get(age) + 1;
        groupMap.put(age, count);
    }
}
```

第一阶段的分组统计工作完成后，接着会来到第二阶段，其中使用了`$sort`操作符，对`_id`字段进行了升序排序，不过这里要注意，因为第二阶段输入的数据，是第一阶段输出的数据，所以第二阶段的`_id`，实际上是原本的`age`字段，这意味着在对年龄做升序排序！


----

2


OK，相信经过这番解释后，大家对`MongoDB`的聚合管道操作有了一定理解，那接着继续看些案例加深印象（也可以尝试着自己练习练习）：

```JavaScript
/* 多字段分组：按食物等级、颜色字段分组，并求出每组的年龄总和 */
db.xiong_mao.aggregate([
    // 1：_id中写多个字段，代表按多字段分组，接着通过$sum求和age字段
    {$group: {_id: {grade:"$food.grade", color:"$color"}, total_age: {$sum:"$age"}}}
]);

/* 分组后过滤：根据年龄分组，然后过滤掉数量小于3的组 */
db.xiong_mao.aggregate([
    // 1：先按年龄进行分组，并通过$sum:1对每组数量进行统计
    {$group: {_id: "$age", count: {$sum:1}}},
    // 2：通过$match操作符，保留数量>3的分组（过滤掉<3的分组）
	{$match: {count: {$gt:3}}}
]);

/* 分组计算：根据颜色分组，求出每组的数量、最大/最小/平均年龄、所有姓名、首/尾的姓名 */
db.xiong_mao.aggregate([
    // 1：按颜色分组
    {$group: {_id: "$color", 
        // 计算每组数量
        count: {$sum:1}, 
        // 计算每组最大年龄
        max_age: {$max: "$age"},
        // 计算每组最小年龄
        min_age: {$min: "$age"},
        // 计算每组平均年龄
        avg_age: {$avg: "$age"},
        // 通过$push把每组的姓名放入到集合中
        names: {$push:"$name"},
        // 获取每组第一个熊猫的姓名
        first_name: {$first: "$name"},
        // 获取每组最后一个熊猫的姓名
        last_name: {$last: "$name"}}}
]);

/* 分组后保留原数据，并基于原_id排序，然后跳过前3条数据，截取5条数据 */
db.xiong_mao.aggregate([
    // 1：先基于color分组，并通过$$ROOT引用原数据，将其保存到数组中
    {$group: {_id: "$color", xiong_mao_list: {$push: "$$ROOT"}}},
    // 2：通过$unwind操作符，将xiong_mao_list数组分解成一条条数据
    {$unwind: {path:'$xiong_mao_list', 
        // 使用index字段记录数组下标，preserveNullAndEmptyArrays可以保证不丢失数据
        includeArrayIndex:"index", preserveNullAndEmptyArrays: true}},
    // 3：基于分解后的_id字段进行排序，1代表升序
    {$sort: {"xiong_mao_list._id": 1}},
    // 4：通过$skip跳过前3条数据
    {$skip: 3},
    // 5：通过$limit获取5条数据
    {$limit: 5}
]);

/* 根据年龄进行判断，大于3岁显示成年、否则显示未成年（输出姓名、结果） */
db.xiong_mao.aggregate([
    // 1：通过$project操作符来完成投影输出
    {$project: {
      // 不显示_id字段，将name字段重命名为：“姓名”
      _id:0, 姓名:"$name",
      // 通过$cond实现逻辑运算，如果年龄>=3，显示成年，否则显示未成年
      result: {
        $cond: {
          if: {$gte: ["$age", 3]},
          then: "成年",
          else: "未成年"
    }}}}
]);
```



### 5.2.5 聚合的要点 

好了，关于聚合管道的案例，暂时就写到这里，想要学习其他操作符的使用，可以参考之前给出的官网链接。这里主要说明几点要素。

首先聚合管道的每个阶段，内存限制一般为`100MB`，如果超出这个限制，执行时会报错，因此当需要处理大型数据集时，记得把`allowDiskUse`选项置为`true`，允许`MongoDB`使用磁盘临时文件来完成计算。

其次呢，使用聚合管道时也要牢记，筛选、过滤类型的阶段，最好放到前面完成，这样有两个好处：一是可以快速将不需要的文档过滤掉，减少管道后续阶段的工作量；二是如果在`$project、$group`这类操作前执行`$match`，`$match`阶段可以使用索引，因为此时属于在操作原本的文档，索引自然不会失效，可如果放到`$project、$group……`后面再执行，原数据被改变后，前面的阶段会形成新的文档，并输出到`$match`阶段中，这时索引不一定能继续生效。

最后，按官网所说，除了`$out、$merge`和`$geoNear`这些阶段外，其他类型的所有阶段，都可以在管道中出现多次，这意味着`MongoDB`会比传统型`SQL`更强大，比如可以多次分组、筛选……，结合管道里的几百个操作符，你可以实现各种复杂场景下的聚合操作。


# 6 嵌套文档的增删改查

在关系型数据库中，我们可以通过树表、主子表等思想，抽象出各种结构以满足业务需求，举个例子理解，比如下单业务中，用户一笔订单可能会包含多个商品，所以会用主子表的思想，对订单数据进行存储，订单数据存到主表中、订单详情数据放到子表，两表之间通过主外键关联，后续可以通过`join`来查询、使用。

但由于`MongoDB`是无模式、半结构化的存储方式，因此无法像传统型数据库那样，通过主外键来关联不同表（集合），毕竟一个集合没有明确的字段定义，可以随意插入不同字段。那`MongoDB`又该如何满足树表、主子表这种业务的存储需求呢？**答案是通过文档嵌套来代替！**

在前面学习`insert`操作时，大家不难得知：`MongoDB`集合中的每个字段，可以继续嵌套`Json`对象，因为`MongoDB`本身就是以`Json`格式存储数据，所以只要是能用`Json`格式表达出来的数据，都可以放到集合中存储，比如：

```JavaScript
db.xiong_mao.insert([
    {_id:12, name:"金熊", age:4, hobby:["吃饭","睡觉"], food:{name:"黄金竹", grade:"S"}}
]);
```

在插入数据时，字段的值可以放入普通类型，也可以放入数组、另一个`Json`对象，所以早期的`MongoDB`，推荐通过嵌入文档，来代替`SQL`中的`join`多表连接查询，前面举例提到的订单、订单详情这种一对多的主子关系，可以用如下方式代替：


下面来聊聊嵌套文档的增删改查，这里跟操作普通文档有些许出入，如下：

```JavaScript
/* 新增单条订单详情：通过order集合的update方法来实现 */
db.order.update(
    // 修改条件：修改_id=1的订单数据
    {_id: 1},
    // 通过$push操作符，往order_details中压入一条新记录
    {$push: {
      order_details: {
        order_detail_id: 3,
        shop_id: 4,
        shop_price: 444.44,
        status: "待发货"
        }
    }}
);

/* 新增多条订单详情记录 */
db.order.update(
  {_id: 1},
  {$push: {
      order_details: {
        // 这里使用$each操作符，声明本次要push多个元素
        $each: [
          {order_detail_id: 4, shop_id: 3, shop_price: 333.33, status: "待发货"},
          {order_detail_id: 5, shop_id: 1, shop_price: 111.11, status: "待发货"}
        ]
      }
	}}
);

/* 删除满足条件的订单详情数据 */
db.order.update(
  {_id: 1},
  // 通过$pull操作符，将order_details满足条件的数据弹出
  {$pull: {
      // 删除order_detail_id大于3的订单详情数据
      order_details: {order_detail_id: {$gt:3}}
    }
});

/* 修改单条满足条件的订单详情数据 */
db.order.update(
  // 这里给定了两个条件，订单ID=1，并且订单详情ID=1
  {_id: 1, "order_details.order_detail_id": 1},
  // 通过$set操作符，来对集合中的文档进行局部修改
  {$set: {
      // 将状态改为已发货，这里的$，表示数组中的当前元素，即条件匹配的数组元素
      "order_details.$.status": "已发货"
  }}
);

/* 修改多条满足条件的订单详情数据 */ 
db.order.update(
  // 先查询到订单ID=1的数据
  {_id: 1},
  {$set: {
      // 这里使用的是$[elem]占位符，代表着要更新的元素
      "order_details.$[elem].status": "已发货"
  }},
  // 这里定义了一个数组过滤器，会把满足条件的订单详情记录筛选出来
  {arrayFilters: [
        // 这里的elem代表数组中的元素，过滤条件为：订单详情ID=2、3的数据
    	{"elem.order_detail_id": {$in: [2,3]}}
    ]}
);

/* 修改满足多个条件的单条数据 */
db.order.update(
  {
    // 这里是基于order_details字段在做条件过滤，可以跨文档（在不同数据行中筛选）
    order_details: {
      // $elemMatch操作符代表匹配多个条件
      $elemMatch: {
        status: "已发货",
        shop_id: 2
    }}
  },
  // 对满足多个条件的单条数据进行修改（要修改多条，参考上个案例的用法即可）
  {$set: {
      "order_details.$.status": "已签收"
  }}
);

/* 查询符合条件的单条数据 */
db.order.find(
    // 查询order_detail_id==1的订单详情数据
    {"order_details.order_detail_id":1}, 
    // 限制返回的字段，不返回_id，order_details.$表示只返回满足条件的订单详情数据
    {"_id":0, "order_details.$":1}
);

/* 查询满足多个条件的多条数据 */
db.order.aggregate([
    // 使用$project操作符完成投影查询
    {$project: {
      // 不返回_id字段
      _id: 0,
      // 只返回order_details字段
      order_details: {
        // 通过$filter操作符，实现按条件过滤数据
        $filter: {
          // 这里相当于for循环，$order_details是要遍历的数组，$detail是别名
          input: "$order_details",
          as: "detail",
          // 这里是过滤的条件，$and表示两个条件都需要满足
          cond: {
            $and: [
              // 返回order_detail_id>=1 && status为“已签收”的数据
              {$gte: ["$$detail.order_detail_id", 1]},
              {$eq: ["$$detail.status", "已签收"]}
            ]
          }
        }
    }}}
]);
```

好了，上面把嵌套文档的增删改查操作简单过了一遍，其实嵌入式文档的`CRUD`，都依赖于外部集合的`CRUD`方法完成，唯一有区别的地方就在于：我们需要结合`$push、$pull、$elemMatch、$[elem]`等各种数组操作符，来实现嵌入式文档的增删改查。

---


不过如若只嵌入了一个文档，而不是一个文档数组时，操作的方法有有些不同，如下：

```JavaScript
// 以之前xiong_mao集合中，id=1的这条数据为例
db.xiong_mao.insert({_id:1, name:"肥肥", age:3, hobby:"竹子"});

// 为其添加一个内嵌文档
db.xiong_mao.update(
	{_id:1},
	{$set: {food: {name:"帝王竹", grade:"A"}}}, 
	{upsert:true}
);

// 查询一次看看这条数据（此时可以看到内嵌文档已经被添加）
db.xiong_mao.find({_id:1});
{
    _id: 1,
    name: '肥肥',
    age: 3,
    hobby: '竹子',
    color: '黑白色',
    food: { name: '帝王竹', grade: 'A' }
}

// 修改内嵌文档中的某个字段值
db.xiong_mao.updateMany(
	{_id:1},
	// 修改单个字段，要用 . 的形式
	{$set: {"food.grade":"S"}}, 
	{upsert:true}
);

// 删除内嵌文档中的单个字段
db.xiong_mao.update(
    {_id:1},
    // 通过$unset操作符，将对应字段置为空即可
    {$unset:{"food.grade":""}},
    {upsert:true}
);

// 删除整个内嵌文档
db.xiong_mao.update(
    {_id:1},
    // 将整个内嵌文档字段置为空即可
    {$unset:{food:""}},
    {upsert:true}
);
```

ok，关于文档嵌入的内容咱们先就此打住，来思考一个问题：**真的所有带有主外键关系的结构，都可以通过文档嵌入代替吗？**

这个答案明显是`NO`，为什么？就拿咱们前面“订单-订单详情”例子中的商品来说，每一笔订单详情记录，都需要跟商品产生绑定关系吧？这时我们总不能把整个商品的数据，全部嵌入到订单详情的某个字段中吧？因为一个商品可以被多次购买！如果真按这样存，假设一个商品单月销量`10W+`，产生的`10W+`订单详情记录，难道都把这个商品的完整数据嵌入一次吗？显然不合理。

正因如此，有些场景下，咱们无法通过文档嵌入来代替原本的多表关联，所以`MongoDB`在`3.2`版本以后，也支持了多个集合之间关联查询，就类似于`SQL`中的`join`一样！只不过功能没`SQL`强大，并且必须在聚合管道中使用，下面一起来看看。

## 6.1 多个集合关联查询


现在假设有商店`shop_store`、商品`product`两个集合，数据如下：

```JavaScript
db.shop_store.insertMany([
    {_id: 1, name: "熊猫高级会所", address:"地球市天上人间街道888号", grade:"五星"},
    {_id: 2, name: "竹子商店", address:"地球市绿竹林街道666号", grade:"五星"}
]);
db.product.insertMany([
    {_id:1, shop_store_id:1, name:"水", description:"能有效缓解口渴", price:2.00},
    {_id:2, shop_store_id:2, name:"米饭", description:"能有效缓解饥饿", price:1.00},
    {_id:3, shop_store_id:1, name:"香烟", description:"能有效缓解寂寞", price:88.88},
    {_id:4, shop_store_id:1, name:"酒", description:"能有效缓解忧愁", price:99.00},
    {_id:5, shop_store_id:1, name:"牛奶", description:"能帮助长身体", price:4.00},
    {_id:6, shop_store_id:2, name:"咖啡", description:"能有效缓解疲劳", price:9.99},
    {_id:7, shop_store_id:1, name:"棉衣", description:"能有效缓解寒冷", price:188.00},
    {_id:8, shop_store_id:2, name:"辣条", description:"能有效缓解嘴馋", price:5.00}
]);
```

在以外，为了实现数据的关联性，我们会直接将商店数据，嵌入到商品数据的某个字段中，而在目前的这个例子中，却是通过`shop_store_id`字段来关联商品所在的商店，查询时又该如何处理呢？


如下：
```JavaScript
db.shop_store.aggregate([
  {
    $lookup: {
      from: "product",
      localField: "_id",
      foreignField: "shop_store_id",
      as: "products"
    }
  }
]);
```

在上述代码中，使用了聚合管道中的`$lookup`操作符，来实现多个集合之间的关联查询，其中主要有四个参数：

- `from`：要关联的集合名称，这里是用商店关联商品，所以写`product`；
- `localField`：`shop_store`集合中用于关联的字段，这里是`_id`；
- `foreignField`：`product`集合中用于关联的字段，这里是`shop_store_id`；
- `as`：指定两个集合匹配的数据，要保存到的字段名称，这里写了`products`。

由于关联查询，也依靠于聚合管道来完成，为此大家可以在关联查询的前后，插入各种业务所需的阶段，以满足各种特殊场景下的需求，不过这里注意：**关联查询结束后，驱动集（调用`aggregate`方法的集合）的字段会完整输出，而被驱动集的字段，会以`Json`对象的形式，放入到指定的字段中，最终形成一个`Json`数组，即案例中的`products`**。

最后，如果你的需求中，需要关联并筛选数据，那么最好将筛选动作放到关联查询前面，尽可能的减小关联查询时的数据集，因为`$lookup`操作符，底层就是两个`for`循环，如果两个集合都有`100W`条数据，未做筛选直接关联查询，此时性能堪忧……



# 7 $type
  
$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。


![](image/Pasted%20image%2020250226215349.png)
  

```js
> db.collectionName.insert({
    title: 'PHP 教程', 
    description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',
    by: 'UrbaneH',
    url: 'http://www.xxx.com',
    tags: ['php'],
    likes: 200
})
> db.collectionName.insert({title: 'Java 教程', 
    description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',
    by: 'UrabaneH',
    url: 'http://www.xxx.com',
    tags: ['java'],
    likes: 150
})
> db.collectionName.insert({title: 'MongoDB 教程', 
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'UrabaneH',
    url: 'http://www.xxx.com',
    tags: ['mongodb'],
    likes: 100
})

```

使用 $type 主要用于选择集合中指定字段指定类型的数据，比方说上面是选取集合中 title 字段中类型为 String 的数据；
```

db.collectionName.find({"title" : {$type : 2}})
或
db.collectionName.find({"title" : {$type : 'string'}})


🖨️输出:

     

{ "_id" : ObjectId("56066542ade2f21f36b0313a"), "title" : "PHP 教程", "description" : "PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。", "by" : "UrbaneH", "url" : "http://www.xxx.com", "tags" : [ "php" ], "likes" : 200 }
{ "_id" : ObjectId("56066549ade2f21f36b0313b"), "title" : "Java 教程", "description" : "Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。", "by" : "UrbaneH", "url" : "http://www.xxx.com", "tags" : [ "java" ], "likes" : 150 }
{ "_id" : ObjectId("5606654fade2f21f36b0313c"), "title" : "MongoDB 教程", "description" : "MongoDB 是一个 Nosql 数据库", "by" : "UrbaneH", "url" : "http://www.xxx.com", "tags" : [ "mongodb" ], "likes" : 100 }

```