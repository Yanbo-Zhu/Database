
# 1 Selbstlerntest 6 - Anfragen in SQL


1
In einem SQL-Statement zur Entwicklung von Anfragen auf Tabellen sind zunächst die 
`Select` Klausel und danach die
`From` Klausel grundlegende Bestandteile.

2
Welche Outer Joins gibt es?

right, full, semi
left, right, half
left, middle, right
left, right, full

Die richtige Antwort ist: left, right, full



3

Ein Full Outer Join entspricht dem kartesischen Produkt, da hier sowohl Zeilen aus der linken, wie auch aus der rechten Tabelle in die Ergebnistabelle einbezogen werden.

Die richtige Antwort ist 'Falsch'.


4
Über ein SELECT ... FROM ... WHERE ... - Statement in SQL sind die folgenden relationalen Grundoperationen abgebildet.

Die richtige Antwort ist: FROM → Join, WHERE → Selektion, SELECT → Projektion


5

Gegeben ist der folgende Ausdruck in Relationenalgebra. Welches SQL-Statement entspricht diesem Ausdruck?

`π[artnr, pos, firma, modell, modelljahr-3](zubehoer).`

Frage 5 Wählen Sie eine oder mehrere Antworten:

- update zubehoer set modelljahr = modelljahr - 3;
- select artnr,pos, firma, modell, (modelljahr - 3)   from zubehoer where modelljahr = '2020';
- select artnr, firma, modell, (modelljahr - 3), pos   from zubehoer;   Reihenfolge der Attribute ist nicht relevant
- select artnr,pos, firma, modell, (modelljahr - 3)   from zubehoer;
- select artnr, pos, firma, (modell - 3), modelljahr   from zubehoer;
- select artnr,pos, firma, modell, (modelljahr - 3) as zurückdatiertesModelljahr   from zubehoer;


Die richtigen Antworten sind: 
select artnr,pos, firma, modell, (modelljahr - 3)   from zubehoer;
select artnr, firma, modell, (modelljahr - 3), pos   from zubehoer;


6

Gegeben ist folgendes Relationenschema der Datenbank matinf:

kdst (kdnr, firma, plz, ort, strasse, vertreter, saldo, umssoll, umshaben, kdgruppe, branche)    kdnr 是 primarschluessel 

Für alle Kunden eines Ortes soll die Summe des Umsatzsolls, der Name des Ortes und die Anzahl der Kunden (in diesem Ort) ausgegeben werden. 

Frage 6 Wählen Sie eine oder mehrere Antworten:

```
select ort, count(ort) as "Anzahl Kunden",  
sum(umssoll) as "Summe Umsatzsoll in EUR"  
from kdst  
group by ort;
```


```
select ort, count(ort), sum(umssoll)  
from kdst  
group by ort;
```


```
select ort, count(ort), sum(umssoll)  
from kdst  
group by kdnr;
```


```
select firma, count(ort), sum(umssoll)  
from kdst  
group by ort;
```


```
select firma, ort, count(ort), sum(umssoll)  
from kdst  
group by ort;
```


第1 2 是对的 





7

Entwerfen Sie für die nachfolgend definierte Tabelle „Name“ eine SQL-Anweisung, die eine Liste aller unterschiedlichen, in der Tabelle vorkommenden Anreden ermittelt.

```
CREATE TABLE Name  
(ID NUMERIC(10) PRIMARY KEY,  
Anrede CHARACTER VARYING(20),  
Vorname CHARACTER VARYING(60),  
Nachname CHARACTER VARYING(60));
```

Frage 7 Wählen Sie eine oder mehrere Antworten:

select distinct(anrede)  
from name

where anrede IN ('Frau', 'Herr');

select unique(anrede)  
from name;

select all(anrede)  
from name;

select anrede  
from name;

select distinct(anrede)  
from name;


选最后一个 





8

Gegeben ist folgendes Relationenschema der Datenbank company:

emp (empno, empname, job, manager, hiredate, salary, commission, deptno)   empno   是primarkey 

Lassen Sie sich bitte alle Verkäufer (SALESMAN) in Abteilung 30 auflisten, die ein Gehalt von mindestens 1500 EUR haben. Die Berufsbezeichnungen sind in der Tabelle in Großbuchstaben, wie oben angegeben, hinterlegt.

Zu diesen Personen sollen alle verfügbaren Informationen angezeigt werden.

Frage 8 Wählen Sie eine oder mehrere Antworten:

```
select *  
from company.emp  
where job='SALESMAN'  
or deptno=30  
and salary>=1500;
```

```
select empno, empname,job,manager, hiredate,salary,commission,deptno  
from company.emp  
where lower(job)='salesman'  
and deptno=30  
and salary>=1500;
```

```
select *  
from company.emp  
where lower(job)='salesman'  
and deptno=30  
and salary>=1500;
```

```
select *  
from company.emp  
where upper(job)='salesman'  
and deptno=30  
and salary>=1500;
```

```
select empno, empname,job,manager, hiredate,salary,commission,deptno  
from company.emp  
where job='SALESMAN'  
and deptno=30  
and salary>=1500;
```

```
select *  
from company.emp  
where job='SALESMAN'  
and deptno=30  
and salary>=1500;
```


```
select *  
from company.emp  
where job='SALESMAN'  
and deptno=30  
or salary>=1500;
```



选 2 ,3, 5, 6, 


9 

Gegeben ist folgendes Relationenschema der Datenbank matinf:

kdst (kdnr, firma, plz, ort, strasse, vertreter, saldo, umssoll, umshaben, kdgruppe, branche)

Lassen Sie sich alle Kunden ausgeben, deren Firmenbezeichnung „AG“ enthält. 

Frage 9 Wählen Sie eine oder mehrere Antworten:

```
select firma  
from kdst  
where firma like '_AG_';
```

```
select firma  
from kdst  
where upper(firma) like '%ag%';
```

```
select firma  
from kdst  
where firma like '%AG_';
```

```
select firma  
from kdst  
where firma like '%AG%';
```

```
select firma  
from kdst  
where lower(firma) like '%ag%';
```


选 4, 5


10 


Wofür stehen die Klausel ORDER BY und die Klausel GROUP BY in einem SELECT-Statement?

Frage 10 Wählen Sie eine oder mehrere Antworten:

ORDER BY - Orientierung, GROUP BY - Gruppierung
GROUP BY - Aggregierung, ORDER BY - Sortierung
GROUP BY - Gruppierung, ORDER BY - Sortierung
ORDER BY - Sortierung, GROUP BY - Graphenbildung
ORDER BY - Sortierung, GROUP BY - Gruppierung

Die richtigen Antworten sind: 
ORDER BY - Sortierung, GROUP BY - Gruppierung,
GROUP BY - Gruppierung, ORDER BY - Sortierung


# 2 Selbstlerntest 7 - Joins, Unteranfragen, Mengenoperationen in SQL-Anfragen



1 

Gegeben ist das Relationenschema der Tabelle emp: 

emp (empno, empname, job, manager, hiredate, salary, commission, deptno)  empno 是 主key 

Welche Aussagen zur nachfolgenden Anfrage auf der Tabelle emp sind zutreffend?

```
select mitarb.empname, mitarb.salary, manager.empname, manager.salary  
from emp mitarb, emp manager  
where mitarb.manager = manager.empno  
and mitarb.salary > manager.salary;
```

Frage 1 Wählen Sie eine oder mehrere Antworten:

In der Anfrage wird ein Self-Join auf der Tabelle emp ausgeführt, wobei der Tabelle die Aliase mitarb und manager zugeordnet werden. 

Die Anfrage enthält in ihrer Ergebnistabelle diejenigen Angestellten, deren Gehalt das ihrer Manager übersteigt, mit deren Namen und Gehalt sowie danach dem Namen und Gehalt des Managers.

Die Anfrage enthält in ihrer Ergebnistabelle diejenigen Angestellten, deren Gehalt das ihrer Manager übersteigt, mit zunächst dem Namen und Gehalt des Managers und danach dem Namen und Gehalt des Angestellten.

Die Anfrage enthält in ihrer Ergebnistabelle diejenigen Manager, deren Gehalt das ihrer Angestellten übersteigt, mit deren Namen und Gehalt sowie danach dem Namen und Gehalt des Angestellten.

In der Anfrage wird ein  Left Outer Join auf der Tabelle emp ausgeführt, wobei der Tabelle die Aliase mitarb und manager zugeordnet werden.

选 1 and 2 





2


Gegeben sei die Relation

vereinsmitglied(nr, vorname, nachname, eintrittsjahr, austrittsjahr)

mit **verpflichtendem** Eintrittsjahr und **optionalem** Ausstrittsjahr. Ein NULL-Wert des Austrittsjahres soll eine noch andauernde Mitgliedschaft anzeigen. Die Datumsangaben starten ab 2000 und liegen in folgendem Format vor: '01.01.01'.

Konzipieren Sie innerhalb einer SQL-Anfrage die korrekte Selektion, die aus dieser Relation die Datensätze all derjenigen Mitglieder ermittelt, die entweder noch im Verein sind oder erst nach mehr als fünf Jahren Mitgliedschaft aus dem Verein ausgetreten sind. Sie dürfen annehmen, dass die Mitgliedschaft nur volle Kalenderjahre währt.

Wie sieht der entsprechende Ausdruck in SQL aus (auf die Projektion muss nicht geachtet werden)?

Frage 2 Wählen Sie eine oder mehrere Antworten:

```
select m.mitgliedsnummer, substr(m.eintrittsjahr,7,2) as eintritt, (substr(m.austrittsjahr,7,2)) as austritt  
from mitgliedschaft m  
where m.austrittsjahr is not null  
or ((substr(m.austrittsjahr,7,2))- substr(m.eintrittsjahr,7,2))>5;
```


```
select *
from vereinsmitglied
where (austrittsjahr is null) or (austrittsjahr - eintrittsjahr)>5;
```


```
select *
from vereinsmitglied
where (austrittsjahr is null) and (austrittsjahr - eintrittsjahr)>5;
```


```
select m.mitgliedsnummer, substr(m.eintrittsjahr,7,2) as eintritt, (substr(m.austrittsjahr,7,2)) as austritt  
from vereinsmitglied m  
where m.austrittsjahr is null  
or ((substr(m.austrittsjahr,7,2))- substr(m.eintrittsjahr,7,2))>5;
```


```
select m.mitgliedsnummer, substr(m.eintrittsjahr,7,2) as eintritt, (substr(m.austrittsjahr,7,2)) as austritt  
from mitgliedschaft m  
where m.austrittsjahr = null  
or ((substr(m.austrittsdatum,7,2))- substr(m.eintrittsdatum,7,2))>5;
```


选 第四个  和第二个 




3


Gegeben ist eine SQL-Anfrage mit einer linken Tabelle mit 5 Zeilen und einer rechte Tabelle mit 9 Zeilen.

Wie viele Zeilen sind in Ihrer Ergebnistabelle, wenn Sie die linke und rechte Tabelle über ein kartesisches Produkt miteinander verknüpfen?

Frage 3 Wählen Sie eine Antwort:

45
9
40
50
5

Die richtige Antwort ist: 45



4

Liefert eine einfache Unteranfrage mehrere Ergebnisse an die äußere Anfrage, dann ...

Frage 4 Antwort

- muss = durch den IN-Operator ersetzt werden
- können die Vergleichsoperatoren =, > oder < problemlos eingesetzt werden
- muss = durch = ANY ersetzt werden
- muss > durch > in Kombination mit ANY oder ALL ersetzt werden
- muss = durch = ALL ersetzt werden
- muss > durch den IN-Operator ersetzt werden





5


Was unterscheidet einen Inner von einem Outer Join?

Frage 5 Wählen Sie eine oder mehrere Antworten:

- Beim Outer Join existieren weniger Zeilen als beim Inner Join.
- Beim Outer Join existieren mehr Zeilen als beim Inner Join.
- Beim Outer Join existieren mehr Spalten als beim Inner Join.
- Beim Outer Join existieren weniger Spalten als beim Inner Join.
- Beim Inner Join existieren mehr Zeilen als beim Outer Join.
- Beim Inner Join existieren weniger Zeilen als beim Outer Join.


Die richtigen Antworten sind: 
Beim Inner Join existieren weniger Zeilen als beim Outer Join., 
Beim Outer Join existieren mehr Zeilen als beim Inner Join.





6 

Was unterscheidet eine einfache von einer korrelierten Unteranfrage?

Frage 6 Wählen Sie eine oder mehrere Antworten:

- Eine korrelierte Unteranfrage wird genau einmal ausgeführt.
- Eine einfache Unteranfrage ist abhängig von der äußeren Anfrage und kann deshalb nicht separat getestet werden.
- Eine einfache Unteranfrage wird einmal ausgeführt.
- Eine einfache Unteranfrage ist unabhängig von der äußeren Anfrage und kann deshalb separat getestet werden.
- Eine korrelierte Unteranfrage ist unabhängig von der äußeren Anfrage und kann deshalb separat getestet werden.
- Eine einfache Unteranfrage wird mehrmals ausgeführt.


Die richtigen Antworten sind: 
- Eine einfache Unteranfrage wird einmal ausgeführt., 
- Eine einfache Unteranfrage ist unabhängig von der äußeren Anfrage und kann deshalb separat getestet werden.




7

Gehen Sie von folgendem Schema der Tabelle vert aus der Übungsdatenbank matinf aus:

VERT (vertreter, name, vorname, plz, ort, stadtteil, strasse, prov, chef).    主key 是 vertreter

Wie sieht die korrekte SQL-Anfrage für diese Aufgabenstellung aus: Es sollen Vertreternummer, Name und Provision derjenigen Vertreter ermittelt werden, deren Provision kleiner ist als die Provision aller Vertreter aus dem Stadtbezirk mit der PLZ „12487“.

Frage 7 Wählen Sie eine oder mehrere Antworten:

```
select v.vertreter, v.name,v.prov  
from matinf.vert v  
where v.prov < all  
(select v.prov  
from matinf.vert v  
where v.plz = '12487');
```

```
select v.vertreter, v.name,v.prov  
from matinf.vert v  
where v.prov < any  
(select (v.prov)  
from matinf.vert v  
where v.plz = '12487');
```

```
select v.vertreter, v.name,v.prov  
from matinf.vert v  
where v.prov <  
(select max(v.prov)  
from matinf.vert v  
where v.plz = '12487');
```


```
select v.vertreter, v.name,v.prov  
from matinf.vert v  
where v.prov <  
(select (v.prov)  
from matinf.vert v  
where v.plz = '12487');
```

```
select v.vertreter, v.name,v.prov  
from matinf.vert v  
where v.prov <  
(select min(v.prov)  
from matinf.vert v  
where v.plz = '12487');
```


```
WITH plzprovision AS  
(SELECT prov AS provInPlz FROM vert where plz=12487)  
SELECT vertreter, name, prov FROM vert  
WHERE prov < all (SELECT (provInPlz) FROM plzprovision);
```


选 1  ,  5,  6 


8

Bei Verwendung des UNION-Operators können in einer SQL-Anfrage aggregierte und detaillierte Daten in einer einzigen Ergebnistabelle ausgegeben werden.

Die richtige Antwort ist 'Wahr'.


9


Gegeben sei die in nachfolgender Tabelle dargestellte Relation „Verweise“, die Querverweise zwischen Websites dokumentiert. Ermitteln Sie die Ergebnisrelation (nebst Schema) für folgende relationale Anfrage:  
```
ρ[(seite1, seite2, seite3, seite4, seite5)]
(  
    π[A.SiteNo,B.SiteNo,C.SiteNo,D.SiteNo,D.LinksTo]
    (  
        σ [A.LinksTo = B.SiteNo Λ B.LinksTo = C.SiteNo Λ C.LinksTo = D.SiteNo]
        (  
            ρ[A](Verweise) x ρ[B](Verweise) x ρ[C](Verweise) x ρ[D](Verweise)
        )
    )
)
```


![](image/Pasted%20image%2020250129093559.png)

答案是 

```
SELECT A.SiteNo seite1, B.SiteNo seite2, C.SiteNo seite3, D.SiteNo seite4, D.LinksTo seite5
from Verweise A, Verweise B, Verweise C, Verweise D
Where A.linksto = B.siteno AND
Where B.linksto = C.siteno AND
Where C.linksto = D.siteno 
```


10

Ein Join kann über die FROM-Klausel alleine gebildet und gesteuert werden oder auch über eine Kombination aus FROM- und WHERE-Klausel gemeinsam. 


Welche Variante zutrifft ist abhängig von der jeweiligen Join-Notation.

Die richtige Antwort ist 'Wahr'.