
# 1 Selbstlerntest 10 - Datenintegrität, Sichten, Rechte und Transaktionen


1
Ein Gleichverbund (Equi-Join) ist sowohl über einen Nested Loop Join als auch einen Hash Join umsetzbar.
答案为 wahr



 2
Gehen Sie von folgendem Relationenschema der Tabelle  „Artikelzubehoer“ aus. Passen Sie die Definition der existierenden Tabelle mit einem SQL-Statement so an, dass das Modelljahr eines Artikels nicht vor dem Gründungsjahr der Herstellerfirma liegen darf.

Artikelzubehoer(ArtNr, Modell, Firma, Modelljahr, EAN, Gruendungsjahr, Pos, Zubehoerteil)
![](image/Pasted%20image%2020250128220425.png)


Frage 2 Wählen Sie eine oder mehrere Antworten:

alter table artikelzubehoer  
add constraint chk_jahr  
CHECK (modelljahr < gruendungsjahr);

alter table artikelzubehoer  
add constraint chk_jahr  
CHECK (modelljahr >= gruendungsjahr);

create table artikelzubehoer  
add constraint chk_jahr  
CHECK (modelljahr >= gruendungsjahr);

alter table artikelzubehoer  
add constraint chk_jahr  
CHECK (modell != firma);

Die Antwort ist richtig.

Die richtige Antwort ist: alter table artikelzubehoer  
add constraint chk_jahr  
CHECK (modelljahr >= gruendungsjahr);



3 

Es ist möglich, einer Rolle B andere Rollen (z.B. Rolle A) zuzuweisen, so dass Privilegien hierarchisch vererbt werden können, z.B. von Rolle A -> Rolle B.

答案是 wahr


4
Welches Prinzip gilt in Zusammenhang mit dem Transaktionsmanagement von relationalen Datenbanken?
答案是 acid 


5

Gehen Sie bitte von nachfolgender Darstellung aus, die 2 Transaktionen zeigt, die einen Wert für Stückmenge aktualisieren sollen: Transaktion 1 soll die Stückmenge um 4 reduzieren, Transaktion 2 soll die Stückmenge um 5 erhöhen. Der Ausgangswert der Stückmenge ist 10.

Was sind mögliche Ergebnisse in Bezug auf den Wert der Stückmenge, wenn beide Transaktionen TA1 und TA2 nicht voneinander isoliert abgelaufen sind?
![](image/Pasted%20image%2020250128220549.png)

答案
entweder 10 + 5  = 15 (wenn beide gleichzeitig beginnen und TA2 als letzte schreibt) oder 10 - 6 = 4 (wenn beide gleichzeitig beginnen und TA1 als letzte schreibt)

不会等于 11


6

Welche Werte liegen bei der Transitionsvariable NEW bei folgenden Operationen (nacheinander) vor:
- bevor ein DELETE ausgeführt wird,
- bevor ein UPDATE ausgeführt wird,
- bevor ein INSERT ausgeführt wird.

Frage 6 Wählen Sie eine oder mehrere Antworten:

neuer Wert, NULL, neuer Wert
NULL, NULL, neuer Wert
neuer Wert, neuer Wert, NULL
NULL, neuer Wert, neuer Wert


Die richtige Antwort ist: NULL, neuer Wert, neuer Wert





7
Wie heißen die Anomalien, die im Mehrbenutzerbetrieb von relationalen Datenbanken bei mangelnder Isolation von Transaktionen auftreten können, wenn konkurrierende Zugriffe zeitgleich ausgeführt werden müssen?

Frage 7 Wählen Sie eine oder mehrere Antworten:
dirty repeat, non-repeatable read, phantom-read
dirty read, non-repeatable read, phantom-read  选这个 
dirty read, non-repeatable read, phantom-write
dirty read, repeatable read, phantom-read




8
Wie sehen die korrekten SQL-Anweisungen in korrekter Reihenfolge aus, mit denen Sie die nachfolgend vergebenen  
Privilegien in umgekehrter Reihenfolge Schritt für Schritt wieder entziehen. Bitte löschen Sie auch die beiden erstellten Rollen.

```
CREATE ROLE controlling; 

CREATE ROLE inventur;

GRANT SELECT ON Artikel, Halle TO PUBLIC;  
GRANT SELECT ON Lagerbestand TO controlling;  
GRANT SELECT, INSERT, UPDATE, DELETE ON Lagerbestand TO inventur;
```

 
 Wählen Sie eine oder mehrere Antworten:

```
drop role inventur;

revoke select, insert, update, delete on lagerbestand from inventur;  
revoke select on artikel, halle from public;

revoke select on lagerbestand from controlling;  
drop role controlling;
```

```
revoke select, insert, update, delete on lagerbestand from inventur;  
drop role inventur;

revoke select on lagerbestand from controlling;  
drop role controlling;

revoke select on artikel, halle from public;
```

```
drop role inventur;

drop role controlling;

revoke select, insert, update, delete on lagerbestand from inventur;

revoke select on artikel, halle from public;

revoke select on lagerbestand from controlling;
```

```
revoke select, insert, update, delete on lagerbestand from inventur;  
drop role inventur;

revoke select on artikel, halle from public;

revoke select on lagerbestand from controlling;  
drop role controlling;
```

```
revoke select on artikel, halle from public;

revoke select, insert, update, delete on lagerbestand from inventur;  
drop role inventur;

revoke select on lagerbestand from controlling;  
drop role controlling;
```

```
revoke select on lagerbestand from inventur;

drop role inventur;

revoke insert, update, delete on lagerbestand from inventur;

revoke select on artikel, halle from public;

revoke select on lagerbestand from controlling;  
drop role controlling;
```

```
revoke select, insert, update, delete on lagerbestand from inventur;  
revoke select on lagerbestand from controlling;  
revoke select on artikel, halle from public;  
drop role inventur;  
drop role controlling;
```

```
revoke select on lagerbestand from inventur;

revoke insert, update, delete on lagerbestand from inventur;

revoke select on lagerbestand from controlling;

drop role inventur;

drop role controlling;
```


只有 这些是对的 其他的都不对 


```
revoke select on lagerbestand from inventur;
revoke insert, update, delete on lagerbestand from inventur;
revoke select on lagerbestand from controlling;

drop role inventur;
drop role controlling;
```

```
revoke select, insert, update, delete on lagerbestand from inventur;
drop role inventur;
revoke select on lagerbestand from controlling;
drop role controlling;
revoke select on artikel, halle from public;
```


```
revoke select on artikel, halle from public;
revoke select, insert, update, delete on lagerbestand from inventur;
drop role inventur;
revoke select on lagerbestand from controlling;
drop role controlling;
```

```
revoke select, insert, update, delete on lagerbestand from inventur;
drop role inventur;
revoke select on artikel, halle from public;
revoke select on lagerbestand from controlling;
drop role controlling;
```


10 


Wie oft wird der nachfolgende Trigger ausgeführt, wenn ein UPDATE in der Tabelle STATUS_LOG 10.000 Zeilen betrifft?

```
CREATE OR REPLACE TRIGGER Status_Check

AFTER INSERT OR UPDATE OF S_STATUS ON AUFKOPF

FOR EACH ROW

when (new.aufnr != 99)
declare
status_alt aufkopf.s_status%TYPE;
BEGIN
    if inserting then
        status_alt := null;
    else
        status_alt := :old.s_status;
    end if;
    
    insert into status_log values(:new.aufnr,status_alt,:new.s_status,sysdate);
    
    dbms_output.put_line('statusänderung protokolliert von auftrag: '|| :new.aufnr);
END;
```

答案 是 0 
die Tabelle STATUS_LOG hat keinen Einfluss auf die Ausführung des Triggers, in sie wird lediglich hineingeschriebe



