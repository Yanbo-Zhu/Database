

# 1 Trigger定义

Aktion aufgrund der Zustandsänderung einer Tabelle
-  Ist lokal angesiedelt (Tabellenbezug) 
    - 在 tabelleDeifinition 之外的语句定义 Trigger-Action
- Wird nicht beschrieben, sondern in SQL und PL/SQL „programmiert"
- Wird ausgelöst durch das DBMS

Umsetzung von Ereignis-Bedingung-Aktionen-Regeln (ECA-Regeln) 
- Ereignis = DB-Operation (DML-Operation)
    - insert, update, delete  , 当发生这些操作的时候, 执行 aktion
- Bedingung Wird bei Ausführung der DB-Operation geprüft (als Prädikat mit Operatoren gemäß Where-Klausel)
    - 当Bedingung 被满足的时候,  执行 aktion 
- Aktion = Folge von DB-Operationen (Beschränkung auf QL- und DML-Operationen momentan)
    - Daten 锁住, 其他人不能用了

Spezielle Form von gespeicherten Prozeduren, Ausführung im DB-Server, Kompilierung
Ausführung einer Menge von SQL- (und PL/SQL-) Statements als Antwort auf eine Veränderung in der DB
Seit SQL-99 im Standard enthalten


# 2 Trigger syntax 

## 2.1 Create trigger

```
create [or replace] trigger TriggerName
{before I after} TriggerEreignis
on TabellenName
[referencing {old I new I old_table I new_table}
[as] TransitionsVariable]
[for each row | for each statement ] 
[when (TriggerBedingung) ]
Begin
TriggerAktion
End;
```

### 2.1.1 `create [or replace]` trigger TriggerName

repleace 为取代一个原有的 trigger 



### 2.1.2 {before I after} TriggerEreignis



  在 mysql 中 不能指定 去观察那个 column 的变化, 只能写为: `before update on kdst`
  在 oracle und postges 可以指定 要去观察那个 column 的变化: `before update of umssoll on kdst`   umssoll 是 table kdst  中的 某个 column 


---

可以给入多个 TriggerEreignis

`after insert or update of kdnr on aufkopf`

---


**`BEFORE` Trigger:**

- Wird vor der Ausführung der **DML-Anweisung** (INSERT, UPDATE, DELETE) ausgelöst.
- Typischerweise verwendet, um:
    - Eingabedaten zu validieren.
    - Änderungen an den Werten vorzunehmen, bevor sie in die Tabelle geschrieben werden.

```sql
CREATE TRIGGER before_insert_example
BEFORE INSERT ON table_name
FOR EACH ROW
BEGIN
    -- Validierung oder Anpassung vor der Einfügung
    IF NEW.column_name IS NULL THEN
        SET NEW.column_name = 'Default Value';
    END IF;
END;

```

---


**`AFTER` Trigger:**
- Wird nach der erfolgreichen Ausführung der **DML-Anweisung** ausgelöst.
- Typischerweise verwendet, um:
    - Änderungen in anderen Tabellen vorzunehmen.
    - Audit-Protokolle zu erstellen.
    - Benachrichtigungen auszulösen.

```sql
CREATE TRIGGER after_update_example
AFTER UPDATE ON table_name
FOR EACH ROW
BEGIN
    -- Protokollierung nach der Aktualisierung
    INSERT INTO audit_log (action, timestamp)
    VALUES ('UPDATE', NOW());
END;

```





### 2.1.3 `[referencing {old | new |  old_table | new_table} [as] TransitionsVariable]`


1 
old, new,  为 zeilen variable ,` old.<attribute_name>` 去取table 中每个单个行的 某个 column 值.  当用一行行比较的时候, 用 new, old 
old_table,  new_table  为 整个 table 的variable  ,   `old_table.<attribute>`.  当不用一行行比较的时候, 用 `new_tabelle.<attribute_tabelle>`

2 
old, new,   old_table,  new_table 为 buildin varibale 如果要使用 这个几个单子, 就不用特意写 referencing old  在 trigger 定义语句中了 


3  起 alias 
这时候 必须写明 referencing old as yanbo 这句出来
然后 之后就用 `yanbo.<attribute_name>`  去取table 中每个单个行的 某个 column 值


### 2.1.4 `[ for each row | for each statement ]` 

For each statement:  这个是 default value, 不需要特意写明 . 就是  action 中的 dml 要对 整个 table 只执行一次 
For each row, 如果要对 each row 都执行一次 action 中的 dml, 则需要写明 for each row 这三个单词

### 2.1.5 when (TriggerBedingung)

就是当 满足 TriggerBedingung, 才能执行  aktion 


### 2.1.6 TriggerAktion

1 set 的使用 
SET NEW.umssoll := OLD.umssoll * 1.25;

set 只能 in mysql,  
oracle 和 progres 中 不需要写set 也有同样的效果 


2 `:` 的使用 
mysql 中 :    `SET NEW.umssoll = OLD.umssoll * 1.25`;
Oracle 和 progres 中 :          `new.umssoll := :old.umsoll*1.25 `


## 2.2 alter trigger

alter trigger TriggerName disable;
Anmerkung: lediglich Aktivieren / Deaktivieren möglich



## 2.3 drop trigger 

drop trigger TriggerName;



# 3 Example 

## 3.1 Example 1 


![](image/Pasted%20image%2020250111235508.png)



Das Umsatzsoll darf höchstens um 25 % wachsen


SQL Standard
```
create trigger tr_kdst
before update of umssoll on kdst
referencing old as oldrow new as newrow
for each row
when (newrow.umssoll > 1.25 * oldrow.umssoll)
set (newrow.umssoll = 125 * oldrow.umssoll);

```


---

Oracle-syntax:
```
begin
:newrow.umssoll := 1.25 * :oldrow.umssoll;
end;
```

```
create trigger tr_kdst
before update of umssoll on kdst
referencing old as oldrow new as newrow
for each row
when (newrow.umssoll > 125 * oldrow.umssoll)
Begin
:newrow.umssoll := 125 * :oldrow.umssoll;
end;
```


---

Änderunqs-Triqqer - MySOL:

Das Umsatzsoll darf höchstens um 25 % wachsen
delimiter //
use matinf//
drop trigger if exists tr_kdst //

```
CREATE TRIGGER tr_kdst
BEFORE UPDATE ON kdst
for each row
BEGIN
    IF new.umssoll > old.umssoll*125 THEN
    set new.umssoll=old.umssoll*125;
    END IF;
END;
```


delimiter


---


Weiteres Beispiel für Änderunqs-Triqqer - Oracle:
Bestandsaktualisierung bei Aktualisierung der gelieferten Menge einer Auftragsposition

%Type - Spaltenvariable
%RowType - Tupelvariable

```
create trigger BestandAktuell
after update of mengegel on aufpos
for each row
declare differenz aufpos.mengegel%TYPE - Variable gleichen Typs;
begin
    differenz := :new.mengegel - :old.mengegel;
    update artst set bestand = bestand - differenz where artnr = :new.artnr;
end;
```




## 3.2 Example 3


![](image/Pasted%20image%2020250112000000.png)



Trigger-Beispiel Oracle

1 
Lösungsansatz: Auftragsstatus kontollieren 

```
CREATE OR REPLACE TRIGGER MATINF.STATUS CHECK
BEFORE UPDATE OF S STATUS ON MATINF.AUFKOPF
FOR EACH ROW
WHEN (new.s_status < old.s_status)
begin
:new.s status := :old.s status;
end;
```

Test
```
update aufkopf
set s_status = s_status-1
where s_status>O;

zurückgesetzt auf alten Status: 2
zurückgesetzt auf alten Status: 2
zurückgesetzt auf alten Status: 1
zurückgesetzt auf alten Status: 3
zurückgesetzt auf alten Status: 2
5 Zeilen wurden aktualisiert.
```

2 
Lösungsansatz Protokollierung
Vorbereitung

```
CREATE TABLE "AUFTRAG HAS STATUS"
("AUFNR" NUMBER NOV NULL ENABLE,
"S STATUS" NUMBER NOT NULL ENABLE,
"DATUM" DATE,
PRIMARY KEY ("AUFNR", "S_STATUS")
... FK ...;
```

Trigger 
```
CREATE OR REPLACE TRIGGER
status_update
AFTER INSERT OR UPDATE OF S_STATUS ON AUFKOPF
FOR EACH ROW
BEGIN
insert into auftrag_has_status
values(:new.aufnr,:new.s_status,sysdate);
dbms_output.put_line('statusänderung protokolliert von auftrag: '|| :new.aufnr);
END;
```

3 
Weitere Beispiele für Protokoll-Trigger:
Protokollierung aller Preisänderungen in Auftragspositionen in Tabelle Preis_Protokoll:

```
create trigger PreisUpdate
after update of preis on aufpos
for each row
Begin 
insert into preis_protokoll values (user,sysdate,:old.preis, :new.preis); 
End;
```

Protokoll jeder Aktion in der Tabelle kdst:

```
create trigger kdstUpdate
after delete or insert or update on kdst
when ( user != 'SYSTEM')
declare statement varchar2(30);

begin
    if deleting then statement := 'DELETE'; end if;
    if inserting then statement := 'INSERT'; end if;
    if updating then statement := 'UPDATE"; end if;
    insert into kdst_protokoll values (user, statement, sysdate);
end;
```



4 
Beispiel für einen Trigger zur Fehlerbehandlung - Werfen von Exceptions:
Nachbildung referenzieller Integrität - Prüfung auf korrekte Kundennr. in Auftragskopf:

```
create or replace trigger checkAuftrag
after insert or update of kdnr on aufkopf
for each row
when (new.kdnr <> 99)
declare
nr number(3);

begin
    select kdnr into nr from kdst k where k.kdnr=:new.kdnr;

    exception
        when no_data_found then 
        raise_application_error(-20000, 'Integrität verletzt');  --- Oracle FehlerbehandlungsProzedur
end;
```

Protokoll der Triggerausführung:
```
SQL> insert into aufkopf(aufnr,kdnr) values (7,333);
insert into aufkopf(aufnr,kdnr)
FEHLER in zeile 1: ORA-20000: Integrität verietzt
ORA-06512: in "SAUER.CHECKAUFTRAG" zeile 7
Oracle - FehlerbehandlungsProzedur
```



## 3.3 PL/SQL-Exkurs - für Oracle-Trigger


![](image/Pasted%20image%2020250112002712.png)

Exkurs SQL/PSM:
- Seit SQL:99 Vorschlag einer DB-programmiersprache zur Formulierung von benutzerdefinierten Routinen mit allen Steuerstrukturen - SQL/PSM (Persistent Stored Modules)
- Nutzung für benutzerdefinierte Routinen (Stored Procedures und User-Defined Functions sowie Trigger)
- Standardkonforme Implementierungen: IBM DB2 SQL/PSM
- Proprietäre DB-Sprache von Oracle: PL/SQL, inzwischen weitgehend standardkonform

Grundstruktur eines PL-SQL-Skript
```
declare
    variablen
begin
    anweisungen
[ exception
    fehlerbehandlungs-anweisungen ]
end
```


• die üblichen Kontrollstrukturen
• Datentypen wie in Oracle und zusätzliche (auch boolean!)
• Variablentypen an DB-Typen anpassen:
```
declare
differenz aufpos.mengegel%TYPE; -- Spaltenvariable
akt_aufpos aufpos%ROWTYPE;   -- Tupelvariable
```

• Laden von Daten in PL/SQL-Variablen:
select spaltel, spalte2 into varl, var2 from tabelle where bedingung;

Achtung:
• select nur zum Laden von Daten in Variablen verwenden,
• keine Anzeige der Ergebnistabelle
• Rudimentäre Ausgabeanweisungen über spezielle PL/SQL- Prozeduren (dbms_output.put_line(AusgabeString))


