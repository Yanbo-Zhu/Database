

# 1 考试内容

constraints 不需要知道
需要知道 如何定义的  primar und fremde schlussell


Delete cascade  的用法

# 2 DML Create table 

Die Datendefinitionssprache (DDL) in SQL ermöglicht es, Tabellen, Indizes, und Sichten in der Datenbank anzulegen und zu modifizieren.

```sql
create table artgru
(gruppe varchar2(2)),
grup_txt varchar2(15),
primary key (gruppe)
```


## 2.1 Primärschlüssel

Primärschlüssel 的特性
- Not Null
- Unique
- pro Tabelle nur eine PrimaryKey oder nur eine Kombinierte PrimaryKey

### 2.1.1 **kombinierte Primärschlüssel**



![](image/Pasted%20image%2020250121200150.png)

Gegeben sind die folgenden Relationen. Mit welchen Befehlen werden korrekt Tabellen dafür angelegt?   



Mitglied(Mitgliedsnummer, Nachname, Vorname)  
Mitgliedschaft(Mitgliedsnummer->Mitglied.Mitgliedsnummer, Eintrittsdatum, Austrittsdatum)


Der **kombinierte Primärschlüssel** (`primary key (mitgliedsnummer, eintrittsdatum)`) stellt sicher, dass kein Mitglied für das gleiche Eintrittsdatum mehrfach erfasst werden kann.
上面不可以写为mitgliedsnummer int primary key, eintrittsdatum date primary key  因为这样就变成了 定义出来了两个 primary key 不是 kombierte key 了 

当只有一个 Primärschlüssel 的时候 可以写为 `mitgliedsnummer int primary key` , 也可以可以写成 `primary key (mitgliedsnummer)` 等价于 `mitgliedsnummer int primary key`


----

正确选项为 


```sql
create table mitglied  
(mitgliedsnummer int,  
nachname varchar(30),  
vorname varchar(30),
primary key (mitgliedsnummer));

create table mitgliedschaft
(mitgliedsnummer int,  
eintrittsdatum date,  
austrittsdatum date,  
primary key (mitgliedsnummer, eintrittsdatum),  
foreign key (mitgliedsnummer) references mitglied(mitgliedsnummer));
```

和 


```sql
create table mitglied  
(mitgliedsnummer int primary key,  
nachname varchar(30),  
vorname varchar(30));


create table mitgliedschaft
(mitgliedsnummer int,  
eintrittsdatum date,  
austrittsdatum date,  
primary key (mitgliedsnummer, eintrittsdatum),  
foreign key (mitgliedsnummer) references mitglied(mitgliedsnummer));
```


---
下面是不正确的 

```sql
create table mitglied
(mitgliedsnummer int primary key,
nachname varchar(30),
vorname varchar(30));

create table mitgliedschaft
(mitgliedsnummer int primary key,
eintrittsdatum date primary key,
austrittsdatum date,
foreign key (mitgliedsnummer) references mitglied(mitgliedsnummer));

```


## 2.2 Referenzierte Relation


```sql
create table artgru
(gruppe varchar2(2)),
grup_txt varchar2(15),
primary key (gruppe)
```


```sql
create table artst
( artnr varchar2(5) primary key
artbez varchar2(25) unique ,
gruppe varchar2(2), 
foreign key (gruppe) references artgru (gruppe) 
on delete ...
on update ... 
);
```


## 2.3 Gefährdung der referenziellen Integrität durch schreibende  Operationen:


![](../04_DDL_DML/image/Pasted%20image%2020250128222930.png)


```sql
create table artgru
(gruppe varchar2(2)),
grup_txt varchar2(15),
primary key (gruppe)
```


```sql
create table artst
( artnr varchar2(5) primary key
artbez varchar2(25) unique ,
gruppe varchar2(2), 
foreign key (gruppe) references artgru (gruppe) 
on delete ...
on update ... 
);
```


- Insert bei referenzierender Relation (FS Wert falsch), z.B.: insert into artst
- Delete bei referenzierter Relation, z.B. delete from artgru
- Update des PS Wertes bei referenzierter Relation
    - z.B. update artgru set gruppe = …
- Update des FS Wertes bei referenzierender Relation,
    - z.B. update artst set gruppe = …


### 2.3.1 no action, restrict, cascade, set null, set default

Optionen zur Behandlung der kritischen DML Operationen ( delete und update) bei referenzierter Relation:
- Verbot: no action Standardverhalten (wenn nicht anders definiert) 
    - no action (optimistisch, Notwendigkeit rollback !!!)
    - restrict ( pessimistisch ) 
- Durchführen und Weiterpropagieren der DML Operation: cascade
- Durchführen der DML Operation und Behandlung des FS Wertes in referenzierender Relation:
    - set null
    - set default

Behandlung der kritischen DML Operationen ( insert und update) bei referenzierender Relation:
Verbot


---


die Optionen - no action, restrict, cascade, set null, set default - zur Behandlung der kritischen Delete- und Update-Operationen wird gesetzt?
- bei CREATE TABLE, beim Fremdschlüssel
- bei ALTER TABLE, beim Fremdschlüssel

---

 on update and on delete 

Implizite Optionen bei Oracle DBMS:
- on update no action default
    - Bitte nicht explizit setzen!
- on delete no action default
    - Bitte nicht explizit setzen!

Explizite Optionen bei Oracle DBMS:
- on delete cascade
- on delete set null
    - Achtung: Nullwerte beachten!

----

Was unterscheidet ON DELETE NO ACTION von ON DELETE RESTRICT?

Frage 2 Wählen Sie eine oder mehrere Antworten:
- die Umsetzung des Verbots der DELETE-Operation
- NO ACTION benutzt - wenn nötig - ein ROLLBACK der Transaktion, während RESTRICT darauf verzichten kann.

以下不是 两者的区别 
- das Ergebnis
- nichts
- die Umsetzung der Erlaubnis der DELETE-Operation


## 2.4 表约束 

not null,   default  'm', unique
# 3 DDL Drop table 


Drop Table 表名字


# 4 DDL alter table

语法
alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;

修改列名
ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;

修改列的类型或约束
ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;

添加新列
ALTER TABLE author ADD COLUMN annual DOUBLE; 

删除列
ALTER TABLE book_author DROP COLUMN annual;

修改表名
ALTER TABLE author RENAME TO book_author;




# 5 DML 


## 5.1 insert


四种方式

1 全插入
insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban', '1950-10-12');

2 全插入 但是顺序颠倒 -> t_student(name,sex,classno,birth,no) 中 顺序不是完全按照 表中原本的字段的顺序 
insert into t_student(name,sex,classno,birth,no) values('lisi','1','gaosan1ban', '1950-10-12',2);

3 部分插入 insert into t_student(name) values('wangwu'); // 会生成一行， 除name字段之外，剩下的所有字段自动插入NULL。

4 字段可以省略不写，但是后面的value对数量和顺序都有要求。不能少写， 不能颠倒
insert into t_student values(1,'jack','0','gaosan2ban','1986-10-23');

5 一次插入多行数据
```
insert into t_student(no,name,sex,classno,birth)
values (3,'rose','1','gaosi2ban','1952-12-14'),(4,'laotie','1','gaosi2ban','1955-12-14'); 注意中间的逗号
```


## 5.2 update

```
UPDATE boys SET boyname='张飞',usercp=10 WHERE id=2;


update emp set sal=sal+sal*0.1 where job='MANAGER';
```

## 5.3 delete 

```
delete from emp where comm=500;
```